--// ===================================================
--//   AUTO AIM BASKETBALL SHOOTER (CLICK + MOVE)
--//   Dynamic Rim Dot (Arc Visualizer)
--//   True Arc-Based Aim Vector Adjuster
--// ===================================================

local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local CoreGui = game:GetService('CoreGui')
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

--// === State ===
local toggleOn, DotsEnabled = true, true
local shootKey, selectedRim = nil, nil

--// === Customization ===
local BASE_HEIGHT = 1.0 -- neutral offset above rim
local ARC_MULT = 1.35 -- how much arc increases with distance
local SMOOTHNESS = 0.25 -- lerp speed for smooth vertical motion
local AUTO_LOCK_DISTANCE = 85 -- rim lock radius

--// === Notify ===
local function notify(msg, color)
    local gui = Instance.new('ScreenGui', CoreGui)
    gui.ResetOnSpawn = false
    local label = Instance.new('TextLabel', gui)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.BackgroundTransparency = 1
    label.TextColor3 = color or Color3.new(1, 1, 1)
    label.Font = Enum.Font.Code
    label.TextSize = 26
    label.Text = msg
    label.Position = UDim2.new(0.5, 0, 0.9, 0)
    task.spawn(function()
        task.wait(1.5)
        gui:Destroy()
    end)
end

--// === Rim Dot System ===
local RimDots, RimHeights = {}, {}
local RimSize =
    Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)

local function addRimDot(rim)
    local dot = Drawing.new('Circle')
    dot.Radius, dot.Filled, dot.Color = 4, true, Color3.new(1, 0, 0)
    RimDots[rim] = dot
    RimHeights[rim] = 0
end

local function removeRimDot(rim)
    if RimDots[rim] then
        RimDots[rim]:Remove()
        RimDots[rim] = nil
        RimHeights[rim] = nil
    end
    if selectedRim == rim then
        selectedRim = nil
    end
end

--// === Real-Time Rim Dot Update ===
RunService.RenderStepped:Connect(function()
    if not DotsEnabled then
        for _, d in pairs(RimDots) do
            d.Visible = false
        end
        return
    end

    local root = plr.Character
        and plr.Character:FindFirstChild('HumanoidRootPart')
    if not root then
        return
    end

    for rim, dot in pairs(RimDots) do
        if rim:IsDescendantOf(workspace) then
            -- distance-based upward arc (farther ‚Üí higher)
            local dist = (rim.Position - root.Position).Magnitude
            local targetY = BASE_HEIGHT + (dist * ARC_MULT)
            local lastY = RimHeights[rim] or 0
            local smoothY = lastY + (targetY - lastY) * SMOOTHNESS
            RimHeights[rim] = smoothY

            local worldPos = rim.Position + Vector3.new(0, smoothY, 0)
            local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
            dot.Position = Vector2.new(screenPos.X, screenPos.Y)
            dot.Visible = onScreen
            dot.Color = (rim == selectedRim) and Color3.new(1, 1, 0)
                or Color3.new(1, 0, 0)
            dot.Radius = (rim == selectedRim) and 6 or 4
        else
            dot.Visible = false
        end
    end
end)

--// === Rim Detection ===
workspace.DescendantAdded:Connect(function(o)
    if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RimSize then
        addRimDot(o)
    end
end)
workspace.DescendantRemoving:Connect(removeRimDot)
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
        addRimDot(v)
    end
end

--// === Auto Rim Lock ===
task.spawn(function()
    while task.wait(0.1) do
        if not toggleOn then
            continue
        end
        local root = plr.Character
            and plr.Character:FindFirstChild('HumanoidRootPart')
        if not root then
            continue
        end
        local best, bestDist = nil, AUTO_LOCK_DISTANCE
        for rim in pairs(RimDots) do
            if rim:IsDescendantOf(workspace) then
                local dist = (rim.Position - root.Position).Magnitude
                if dist < bestDist then
                    local _, on = Camera:WorldToViewportPoint(rim.Position)
                    if on then
                        best, bestDist = rim, dist
                    end
                end
            end
        end
        if best and best ~= selectedRim then
            selectedRim = best
            notify('üéØ Auto-Locked Nearest Rim', Color3.fromRGB(255, 230, 0))
        end
    end
end)

--// === Toggles ===
UserInputService.InputBegan:Connect(function(i, gp)
    if gp then
        return
    end
    if i.KeyCode == Enum.KeyCode.O then
        DotsEnabled = not DotsEnabled
    elseif i.KeyCode == Enum.KeyCode.V then
        toggleOn = not toggleOn
        notify(
            toggleOn and 'System ON' or 'System OFF',
            toggleOn and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)
        )
    end
end)

--// === Capture Shoot Key ===
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
    local m = getnamecallmethod()
    if m == 'FireServer' and self == shootRemote then
        local args = { ... }
        if type(args[3]) == 'string' and not shootKey then
            shootKey = args[3]
            print('[Captured ShootKey]:', shootKey)
            notify('Shoot key captured!', Color3.new(0, 1, 0))
        end
    end
    return old(self, ...)
end)

--// === Movement Offset ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
    if tick() - lastTick > 0.1 then
        local hum = plr.Character
            and plr.Character:FindFirstChildOfClass('Humanoid')
        local moveDir = (hum and hum.MoveDirection) or Vector3.zero
        moveOffset = Vector3.new(moveDir.X * 1.5, 0, moveDir.Z * 1.5)
        lastTick = tick()
    end
    return moveOffset
end

--// === True Arc Calculation ===
local function computeArc(dist)
    -- Farther = higher vertical arc
    return Vector3.new(0, BASE_HEIGHT + (dist * ARC_MULT), 0)
end

local function smartAim(rim)
    local offset = computeOffset()
    local root = plr.Character
        and plr.Character:FindFirstChild('HumanoidRootPart')
    if not root then
        return rim.Position
    end
    local dist = (root.Position - rim.Position).Magnitude
    local arc = computeArc(dist)
    return rim.Position + arc - offset
end

--// === Tracer Line ===
local tracer = Drawing.new('Line')
tracer.Thickness = 3
tracer.Color = Color3.fromRGB(0, 255, 255)
tracer.Transparency = 1
tracer.Visible = true

RunService.RenderStepped:Connect(function()
    if not toggleOn then
        tracer.Visible = false
        return
    end
    local root = plr.Character
        and plr.Character:FindFirstChild('HumanoidRootPart')
    if not root or not selectedRim then
        tracer.Visible = false
        return
    end

    local aimPos = smartAim(selectedRim)
    local a, onA = Camera:WorldToViewportPoint(root.Position)
    local b, onB = Camera:WorldToViewportPoint(aimPos)

    if not onA then
        a = { X = Camera.ViewportSize.X / 2, Y = Camera.ViewportSize.Y / 2 }
    end
    if not onB then
        b = {
            X = math.clamp(b.X, 0, Camera.ViewportSize.X),
            Y = math.clamp(b.Y, 0, Camera.ViewportSize.Y),
        }
    end

    tracer.From = Vector2.new(a.X, a.Y)
    tracer.To = Vector2.new(b.X, b.Y)
    local dist = (root.Position - aimPos).Magnitude
    tracer.Thickness = math.clamp(3 + (30 / dist), 2, 5)
    tracer.Visible = true
end)

--// === Shooting ===
local function shootAtTarget()
    if not (selectedRim and selectedRim:IsDescendantOf(workspace)) then
        return notify('‚ùå No Target', Color3.new(1, 0.3, 0.3))
    end
    if not shootKey then
        return notify('‚öôÔ∏è Shoot Key Missing', Color3.new(1, 0.8, 0.3))
    end

    local char = plr.Character
    if not char then
        return
    end
    local head, root = char:FindFirstChild('Head'), char.PrimaryPart
    if not (head and root) then
        return
    end

    local aimPos = smartAim(selectedRim)
    local dir = (aimPos - head.Position).Unit
    local shootFrom = root.Position + dir * 3.8
    if shootFrom.Y - root.Position.Y < 4 then
        shootFrom = root.Position + dir * 4
    end

    shootRemote:FireServer(aimPos, shootFrom, shootKey)
    notify('üèÄ Shot Fired!', Color3.new(0, 1, 0))
end

UserInputService.InputBegan:Connect(function(i, gp)
    if gp or not toggleOn then
        return
    end
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        shootAtTarget()
    end
end)

print('[üèÄ Auto Aim Basketball] Arc Visualizer + Real Aim Vector Loaded.')
print('[V] Toggle system | [O] Toggle dots')
